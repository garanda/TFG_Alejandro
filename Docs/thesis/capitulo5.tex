\chapter{Conjunto de Datos de Prueba.}\label{cap:capitulo5}

En este capítulo se explica el modelo de Datos utilizado en este trabajo, a partir del cual se van a realizar las distintas Conciliaciones. Para ello, se realizarán una serie de operaciones de reestructuración, tras las cuales, se asegurará la fiabilidad y la consistencia de estos datos.
 
\section{Conjunto de Datos Inicial.}

Como se comentaba en el capítulo~\ref{cap:capitulo3}, el Sistema de Etiquetado elegido en este trabajo es Delicious (\cite{delicious}). En este sistema, los Usuarios que pertenecen al sistema tienen la posibilidad de introducir ciertos Enlaces (objetos) y añadir a éstos ciertas Etiquetas (atributos). Definiremos que una {\bf etiquetación} es el conjunto de etiquetas asignadas a un enlace concreto. De esta forma, los objetos del sistema pueden ser introducidos por múltiples usuarios; sin embargo, la etiquetación para cada uno de ellos puede ser diferente en función del usuario. En el capítulo~\ref{cap:capitulo3} se hace mayor referencia sobre los Sistemas de Etiquetado, aportando conclusiones comentadas en \cite{golder}, \cite{smith} o \cite{van}.

Se define nuestro {\bf Sistema de Etiquetado $S$} como la siguiente tupla :
\begin{center}
$ {\cal F} := <U, E, R, Y> $
\end{center}
cuyos parámetros son:

\begin{itemize}
	\item {\bf U} es el conjunto de Usuarios.
	\item {\bf E} es el conjunto de Enlaces (Objetos del Sistema de Etiquetado).
	\item {\bf R} es el conjunto de Etiquetas (Atributos del Sistema de Etiquetado).
	\item {\bf Y} es una Relación entre U, E y R; de forma que $Y \subseteq (U \times{E \times{R}})$.
\end{itemize}

Según el model anterior, se puede construir fácilmente una Base de Datos (BD) que represente dichos datos. De esta forma, se obtiene las siguientes tablas, pertenecientes a la BD \emph{{\bf conciliacion}}:

\begin{itemize}
	\item Tabla \emph{{\bf users}}: (\underline{int id}, String user, ..., String user\_url). El campo $id$ es la clave primaria, y nos permitirá diferenciar unos usuarios de otros. Existen otros campos que no son relevantes en este trabajo.
	\item Tabla \emph{{\bf links}}: (\underline{int id}, String title, String url, ...). El campo $id$ es la clave primaria, y nos permitirá diferenciar unos enlaces de otros. No se asegura que el campo $url$ sea único, por lo que se deberá arreglar posteriormente. Existen otros campos que no son relevantes en este trabajo.
	\item Tabla \emph{{\bf tags}}: (\underline{int id}, String tag). El campo $id$ es la clave primaria, y nos permitirá diferenciar unas etiquetas de otras. Igualmente, el campo $tag$ es único.
	\item Tabla \emph{{\bf linktags}}: (\underline{int link\_id, int tag\_id,  int user\_id}). La tupla formada por los campos $<link\_id, tag\_id, user\_id>$ conforman la clave primaria, y nos permitirá diferenciar las diferentes etiquetaciones.
\end{itemize}


La recuperación de los datos se ha realizado mediante un proceso de navegación por Delicious, en el que inicialmente se realiza una búsqueda de la etiqueta \emph{\bf haskell}, de forma que pueda ser una etiqueta suficientemente significativa desde un punto de vista semántico. La justificación de la elección de esta etiqueta son las connotaciones que ella misma conlleva: ausencia de polisemia de la etiqueta o ausencia de sinonimía con otras etiquetas; ya que es un término que se da en un campo de actuación muy concreto. Esto nos ayudará a reducir el número de ambigüedades clásicas que ocurren en este tipo de sistemas. Por tanto, el conjunto de datos es un subconjunto en el que todos los objetos están etiquetados con esta etiqueta. Obviamente, el conjunto de datos contiene la etiquetación completa sobre dichos enlaces; así como información sobre estos y la información de los usuarios propietarios de los que se ha obtenido la información.

Hay que indicar que toda la información obtenida se encuentra de forma pública en el sistema Delicious (\cite{delicious}).

Por último, hay que indicar que el conjunto de datos no es completo; ya que no asegura que para cierto usuario, se encuentren todas los enlaces existentes, en los que dicho usuario ha etiquetado con la etiqueta haskell. Igualmente, no se puede asegurar que para cierto enlace, se encuentren todas las etiquetaciones de todos los usuarios que incluyan dicha etiqueta. Sin embargo, el Conjunto de Datos extraído se considera lo suficientemente representativo, al estar inicialmente formado por:
\begin{itemize}
	\item 4327 usuarios.
	\item 3163 enlaces.
	\item 2715 etiquetas.
	\item 57497 tuplas.
\end{itemize}




\section{Operaciones de Reestructuración.}

Como se ha comentado anteriormente, es necesario llevar a cabo una serie de tareas de reestructuración de los datos, con el fin de garantizar la fiabilidad y consistencia del Conjunto, antes de trabajar con ellos. De esta forma, se evitarán ciertos errores estructurales en el futuro. Las diferentes tareas que se llevan a cabo son:

\subsection{Eliminar Etiquetas Irrelevantes.}

\subsubsection{Definición de la tarea.}

La primera tarea de limpieza que se va a llevar a cabo es eliminar todas aquellas etiquetas que sean irrelevantes en el sistema, ya sea por mala escritura, el uso de caracteres ilegibles o, por ejemplo, la etiqueta $haskell$, que al estar presente en todos los enlaces, no es significativa. Para ello, vamos a crear un script que nos permita eliminar una etiqueta (mediante su ID o su nombre). Para ello, se tendrá que:
\begin{itemize}
\item    Eliminar el registro de dicha etiqueta en la tabla tags.
\item    Eliminar todos registros de enlaces-etiquetas-usuarios de la tabla linktags dónde aparezca dicha etiqueta.
\item    Comprobar si tras haber eliminado la etiqueta, algún enlace ha quedado sin etiquetación. Esto representaría un fallo de incoherencia en la BD, ya que dicho enlace seguiría existiendo en la tabla links, pero, sin embargo, no tendría ninguna ocurrencia en la tabla linktags. Por tanto, se realizará esa comprobación, y se eliminarán dichos enlaces.
\end{itemize}

\subsubsection{Implementación de la tarea.}

El Script ha sido realizado en Java. Las fases que se llevan a cabo son:

\begin{enumerate}
\item    Se buscan los enlaces que están etiquetados con la etiqueta que va a ser borrada, junto con el número de etiquetas diferentes con las que está etiquetado.
\item    En caso de que esté número sea 1, entonces sólo está etiquetado con la etiqueta que va a ser eliminada. En este caso, se elimina dicho enlace de la tabla links.
\item    Se eliminan todas las 3-tuplas de enlaces-etiqueta-usuario de la linktags tabla en las que el campo etiqueta sea precisamente la etiqueta que va a ser eliminada.
\item    Finalmente, se elimina la etiqueta de la tabla tags.
\end{enumerate}

Como sistema de seguridad, se usará una copia de seguridad de la base de datos para guardar todos los cambios, de forma que los datos originales siempre sean conservados.



\subsubsection{Resultados y Conclusiones.}

La ejecución de dicha tarea supone:
\begin{itemize}
\item    La eliminación de 45 etiquetas ($tags$).
\item    La eliminación de 101 enlaces ($links$).
\item    La eliminación de 10550 3-tuplas enlaces-etiquetas-usuarios ($linktags$).
\end{itemize}
Por una parte, se ha eliminado la etiqueta “masiva” haskell. Esta etiqueta, al encontrarse en todos los enlaces, no representaba ninguna información adicional. Recuérdese que la base de datos es un subconjunto de enlaces que contienen dicha etiqueta.

Por otra parte, el resto de etiquetas del sistema, son etiquetas marginales; es decir, su relevacia en el sistema es mínima (casi nula). Todas estas etiquetas también pueden ser igualmente filtradas según diferentes criterios al procesarse en un grafo: relevancia de la etiqueta en el sistema (peso del nodo), número de relaciones con otras etiquetas (grado nodal de la etiqueta), u otros criterios que se consideren. Tanto en el caso del peso, cuyo peso es mínimo, o el caso del grado nodal, cuyo grado es mínimo, no pasarían el filtro de procesado de los grafos, por lo que serían eliminadas.

En conclusión, este proceso de limpieza es bueno porque elimina información no relevante antes de generar futuros grafo o trabajar con los datos previos a la conciliación. Sin embargo, no aporta grandes cambios a posteriori, ya que son etiquetas marginales con poca representatividad en el sistema.

\subsection{Eliminar Enlaces iguales.}

\subsubsection{Definición de la tarea.}

Esta tarea tiene como objetivo agrupar aquellos enlaces cuya URL sea idéntica en un único registro; es decir, que si existen dos enlaces con la misma URL pero en dos registros diferentes, se simplificarán en alguno de los dos (cualquiera de ellos), de forma que sólo haya un único registro de dicha URL, y además, se actualizarán todos los registros de $linktags$ de forma que las etiquetaciones (de cualquier usuario y/o cualquier etiqueta) del enlace que va a ser eliminado, pasen a ser etiquetaciones del enlace conservado.

\subsubsection{Implementación de la tarea.}

Se realiza un Script, en Java, con los siguientes pasos:
\begin{enumerate}
\item    Se buscan los pares de enlaces cuyos ID’s son distintos pero sus URL’s son iguales (tabla links).
\item    Para cada par de los anteriores, se buscan todas sus tuplas de etiquetación en linktags.
\item    En caso de que existan dos tuplas iguales (una para cada enlace), se elimina la del enlace de menor ID.
\item    En caso contrario, se actualiza la tupla del enlace de mayor ID con valor del otro enlace.
\item    Se elimina el enlace de menor ID en la tabla links.
\end{enumerate}


\subsubsection{Resultados y Conclusiones.}

Se extraen los siguientes resultados:
\begin{itemize}
\item    Eliminación de 14 enlaces (links).
\item    Eliminación de 3 tuplas (linktags).
\item    Actualización de 552 tuplas (linktags).
\end{itemize}



\subsection{Eliminar Enlaces Equivalentes.}

\subsubsection{Definición de la tarea.}

Esta tarea trata de buscar todos aquellos enlaces equivalentes; es decir, aquellos que se encuentra duplicados en el sistema; y agruparlos en un único enlace. Los enlaces que se encuentran duplicados son aquellos que, siendo el mismo enlace, tienen varias referencias distintas en la BD. Pongamos por ejemplo los siguientes tres enlaces, que son el mismo, pero que en nuestra BD tiene tres referencias diferentes:
\begin{itemize}
  \item http://book.realworldhaskell.org/read
  \item http://book.realworldhaskell.org/read/
  \item http://book.realworldhaskell.org/read/index.html
\end{itemize}

El propósito de esta tarea será encontrarlos automáticamente a partir de una serie de reglas descritas, agruparlos en un único enlaces, y eliminar todas las incongruencias en la BD que produzca esta agrupación.

Se definen las siguientes reglas:
\begin{itemize}
\item    Un enlace que no acaba en ‘/’ y otro con la misma URL añadiendo ‘/’ al final, son el mismo enlace (Ejemplos 1 y 2).
\item    Un enlace que no acaba en ‘/’ y otro con la misma URL añadiendo “/index.html” al final, son el mismo enlace (Ejemplos 1 y 3).
\item    Un enlace que no acaba en ‘/’ y otro con la misma URL añadiendo “/index.php” al final, son el mismo enlace.
\end{itemize}

\subsubsection{Implementación de la tarea.}

El Script automático ha sido realizado en Java. Las fases que se llevan a cabo son:
\begin{enumerate}
\item    Se buscan todos los enlaces del sistema (links).
\item    Para cada enlace que no acabe en ‘/’, se buscan todos aquellos que cumplan alguna de las reglas de corrección descritas anteriormente.
\item    Para cada par de enlace de 1 y enlace de 2 encontrados, se buscan las 3-tuplas enlace-etiqueta-usuario (linktags). Este paso se realiza porque existen usuarios que tienen etiquetados ambos enlaces de la misma forma. Es un paso de verificación para los siguientes pasos:
\item    Si el usuario tiene etiquetados ambos enlaces de la misma forma, se elimina la etiquetación de alguno de los enlaces.
\item    En caso contrario, se actualizan las tuplas para que sólo existan para un enlace, y el otro quede vacío de tuplas.
\item    Finalmente, el enlace que no tiene ocurrencias en la tabla linktags, se elimina de la tabla links.
\end{enumerate}


\subsubsection{Resultados y Conclusiones.}

El resultado de ejecutar esta tarea es:
\begin{itemize}
\item    La eliminación de 19 enlaces (links).
\item    La eliminación de 40 3-tuplas enlace-etiqueta-usuario (linktags).
\item    La actualización de 4086 3-tuplas enlace-etiqueta-usuario (linktags).
\end{itemize}
Es interesante el resultado de esta tarea, ya que partiendo de un total de 46947 tuplas, se han modificado o eliminado 4126 de ellas, lo que supone un 8,79\%.


\subsection{Simplificar etiquetas singular-plural.}

\subsubsection{Definición de la tarea.}

Con esta tarea se pretende corregir todos aquellos errores de etiquetación en los que, para un mismo concepto, existen diferentes etiquetas que lo definen. Un típico error de este tipo es encontrar etiquetas diferentes para el mismo término, escrito uno en singular, y otro en plural. En esta tarea, nos centraremos en buscar y resolver algunos de estos errores singular-plurar (no todos) de una forma autormática.

La regla que usaremos para encontrar dichos errores es una etiqueta y otra que contenga el mismo texto más ‘s’, son la misma etiqueta (singular-plurarl), teniendo que agruparlas en una sola.

Hay que indicar que esta regla no es ni correcta ni completa.
\begin{itemize}
\item    No es correcta porque puede encontrar pares que no se correspondan a singular-plurar. Por ejemplo, las etiquetas C y cs corresponderían con etiquetas diferentes, que no deberían agruparse. Estos casos concretos tendrán que ser tratados como excepciones si se quiere usar este proceso.
\item    No es completa porque no encuentra todos los pares singular-plural. Por ejemplo, las etiquetas process y processes no son encontradas por esta regla y SÍ deberían agruparse al tratarse de la misma etiqueta. Igualmente, estos casos tendrán que ser corregidos manualmente si se quiere usar este proceso.
\end{itemize}

\subsubsection{Implementación de la tarea.}

El Script automático ha sido realizado en Java. Las fases que se llevan a cabo son:
\begin{enumerate}
\item    Se buscan todas las etiquetas del sistema (tags).
\item    Para cada etiqueta, se busca si existe la misma etiqueta añadiéndole una ‘s’ al final.
\item    Para cada par de etiqueta de 1 y etiqueta de 2 encontrados, se buscan las 3-tuplas enlace-etiqueta-usuario (linktags). Este paso se realiza porque existen usuarios que tienen enlaces etiquetados con ambos etiquetas. Es un paso de verificación para los siguientes pasos:
\item    Si el usuario tiene algún enlace etiquetado con ambas etiquetas, se elimina la etiquetación de alguno de las etiquetas.
\item    En caso contrario, se actualizan las tuplas para que sólo existan para una etiqueta, y la otra se elimine.
\item    Finalmente, se elimina la etiqueta (tags) que no tiene ninguna ocurrencia.
\end{enumerate}

\subsubsection{Ejecución de la tarea.}


La ejecución de esta tarea ha encontrado algunas excepciones, como: cs (id=211), iOS (id=614), css (id=687), DS (id=2148), js (id=1636). Estas excepciones, una vez que han sido capturadas, se insertan en la función para que no sean consideradas; se vuelve al estado anterior del sistema y se vuelve a ejecutar la tarea.

\subsubsection{Resultados y Conclusiones.}

El resultado de ejecutar la tarea (una vez corregidas las excepciones) es:
\begin{itemize}
\item    Eliminación de 191 etiquetas (tags).
\item    Eliminación de 1667 3-tuplas de enlace-etiqueta-usuario (linktags).
\item    Actualización de 3756 3-tuplas de enlace-etiqueta-usuario (linktags).
\end{itemize}

Es interesante el resultado de esta tarea, ya que partiendo de un total de 46907 tuplas, se han modificado o eliminado, 5423 de ellas, lo que supone un 11,56\%. 



\subsection{Agrupar Etiquetas Equivalentes.}

\subsubsection{Definición de la tarea.}

Esta tarea tiene como objetivo resolver las diferentes etiquetaciones que, para distintas escrituras de una etiqueta, todas representan el mismo término. Es una tarea que se realizará manualmente, por lo que requiere el conocimiento a priori de los conjuntos de etiquetas que van a ser agrupados.

Por ejmplo, las etiquetas mathematics (id=284), mathematica (id=1918), mathematical (id=1745) y mathemtics (id=2447), serán agrupadas con la etiqueta math (id=66).

\subsubsection{Implementación de la tarea.}

El Script está realizado en Java, y se las fases del proceso son:
\begin{enumerate}
\item    El usuario introduce manualmente el conjunto de etiquetas que van a ser simplificadas, así como la etiqueta que va a agruparlas. Se usará el campo id, que es, además, la clave primaria de la tabla tags.
\item    Para cada par de etiqueta del conjunto y etiqueta “agrupadora”, se buscan las 3-tuplas enlace-etiqueta-usuario (linktags). Este paso se realiza porque existen usuarios que tienen enlaces etiquetados con ambos etiquetas. Es un paso de verificación para los siguientes pasos:
\item    Si el usuario tiene algún enlace etiquetado con ambas etiquetas, se elimina la etiquetación de alguno de las etiquetas.
\item    En caso contrario, se actualizan las tuplas para que sólo existan para una etiqueta, y la otra se elimine.
\item    Finalmente, se elimina la etiqueta (tags) que no tiene ninguna ocurrencia.
\end{enumerate}

\subsubsection{Ejecución de la tarea.}

La ejecución de la tarea se lleva a cabo con los siguientes conjuntos:

\begin{itemize}
\item    Conjunto: $mathematics$ (id=284), $mathematica$ (id=1918), $mathematical$ (id=1745), $mathemtics$ (id=2447), agrupados en {\bf \em math} (id=66).

\item    Conjunto: $to\-read$ (id=681), $unread$ (id=1022), $to\_read$ (id=1030), $2read$ (id=1260), $\_toread$ (id=1418), {\em :$toread$} (id=1515), $*toread$ (id=1530), {\em $to$:$read$} (id=1554), $todo.read$ (id=1612), $toread!$ (id=1627), $toreadlater$ (id=1953), $read\_later$ (id=2326), $later\-read$ (id=2420), agrupados en {\bf \em toread} (id=164).

\item    Conjunto: $*Programming$ (id=603), $programmation$ (id=120), {\em $programaci$Ã$?n$} (id=930), $programming.haskel$ (id=1276), $programmin$ (id=1357), $programing$ (id=1359), $programacao$ (id=1362), $Haskell\_Programming$ (id=1399), $programacion$ (id=1420), {\em $programa$Ã§Ã£$o$} (id=1963), agrupados en {\bf \em programming} (id=4).

\item    Conjunto: $functional\-programming$ (id=131), $functional\_programming$ (id=290), $functional\-language$ (id=423), $Functional.Programming$ (id=491), $programming.functional$ (id=1604), $functionalprog$ (id=1611), \\ {\em $functional$+$programming$} (id=1749), agrupados en {\bf \em functionalprogramming} (id=77).

\item    Conjunto: $e\-book$ (id=1444), $onlinebooks$ (id=1577), $online-book$ (id=1453), $books\-on\-line$ (id=1514), agrupados en {\bf \em ebook} (id=23).

\item    Conjunto: $programming\-language$ (id=234), $programming\_language$ (id=832), $proglanguages$ (id=1330), $proglang$ (id=1352), $prog\_languages$ (id=1591), agrupados en {\bf \em programminglanguage} (id=665).

\item    Conjunto: $langauges$ (id=1670), $lang$ (id=694), $languag$ (id=1033), $languaged$ (id=1586), agrupados en {\bf \em language} (id=5).

\item    Conjunto: $tuto$ (id=1466), agrupados en {\bf \em tutorial} (id=6).

\item    Conjunto: $referencc$ (id=1614), $referenz$ (id=1989), $:reference$ (id=2464), $refs$ (id=2703), agrupados en {\bf \em reference} (id=39).
\end{itemize}

\subsubsection{Resultados y Conclusiones.}

El resultado de esta tarea es:
\begin{itemize}
\item    Eliminación de 52 etiquetas.
\item    Eliminación de 158 3-tuplas de enlace-etiqueta-usuario (linktags).
\item    Actualización de 611 3-tuplas de enlace-etiqueta-usuario (linktags).
\end{itemize}

Es interesante el resultado de esta tarea, ya que partiendo de un total de 45240 tuplas, se han modificado o eliminado, 769 de ellas, lo que supone menos del 1,7\%. Por tanto, no se esperan grandes cambios relevantes por los cambios anteriores. Sin embargo, siempre es útil liberar la BD de información basura.





\subsection{Eliminar Usuarios, Enlaces o Etiquetas sin Etiquetación.}

\subsubsection{Definición de la tarea.}

Con esta tarea se eliminarán todos aquellos registros, tanto de usuarios, etiquetas o enlaces, que tras las operaciones anteriores de limpieza, haya quedado sin etiquetación alguna. Es decir, no tiene sentido, por ejemplo, tener registrado un usuario en el sistema que no tenga ningún enlace etiquetado; por tanto, éste se eliminará. Ídem para los enlaces que no estén etiquetados por ningún usuario, y para las etiquetas que no se usen en ninguna etiquetación.

\subsubsection{Implementación de la tarea.}

Se realiza un Script en Java, con los siguientes pasos:
\begin{enumerate}
\item    Buscar usuarios que no participen en ninguna etiquetación, y eliminarlos.
\item    Buscar enlaces que no pertenezcan a ninguna etiquetación, y eliminarlos.
\item    Buscar etiquetas que no formen parte de ninguna etiquetación, y eliminarlas.
\end{enumerate}


\subsubsection{Resultados y Conclusiones.}

Tras la ejecución de esta tarea, se eliminan:
\begin{itemize}
\item    68 usuarios.
\item    0 etiquetas.
\item    1 enlace.
\end{itemize}

\section{Conjunto de Prueba Obtenido.}

Tras todas las operaciones anteriores, el Conjunto de Pruebas final está compuesto por:
\begin{itemize}
	\item 4259 usuarios.
	\item 3028 enlaces.
	\item 2427 etiquetas.
	\item 45079 tuplas.
\end{itemize}

Además, se añade la siguiente tabla, dónde se almacenarán los resultados de la Conciliación global del sistema:
\begin{itemize}
	\item Tabla \emph{{\bf conciliacion}}: (\underline{int user\_id1, int user\_id2,  int link\_id, int tag\_id,} \\ \underline{int umbral}). La tupla formada por todos los campos de la tabla, conforma la clave primaria, y nos permitirá diferenciar las diferentes etiquetaciones producidas para un Contexto Común de dos usuarios (\emph{user\_id1} y \emph{user\_id2}); usuarios que comparten un número de objetos (enlaces) expresados por \emph{umbral}.
\end{itemize}



